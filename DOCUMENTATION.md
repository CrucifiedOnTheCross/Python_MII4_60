# Техническая документация системы цифровой интерферометрии MII4_60 Python

## 1. Введение

### 1.1 Назначение системы

Система MII4_60 Python представляет собой комплексное программное решение для проведения высокоточных интерферометрических измерений методом фазового сдвига. Система предназначена для анализа оптических поверхностей, измерения деформаций, определения профилей поверхности и контроля качества оптических элементов в научных и промышленных применениях.

### 1.2 Область применения

- Контроль качества оптических элементов
- Измерение деформаций и напряжений
- Анализ шероховатости поверхности
- Метрология прецизионных деталей
- Научные исследования в области оптики
- Образовательные цели в области интерферометрии

### 1.3 Принцип работы

Система основана на методе фазового сдвига, при котором анализируется серия интерферограмм с известными фазовыми сдвигами между опорным и объектным пучками. Математическая обработка этих интерферограмм позволяет восстановить фазовое распределение, которое пропорционально профилю исследуемой поверхности.

## 2. Архитектура системы

### 2.1 Общая архитектура

Система построена по модульному принципу с четким разделением ответственности между компонентами:

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   GUI Module    │    │ Hardware Module │    │  Core Module    │
│                 │    │                 │    │                 │
│ - MainWindow    │◄──►│ - CameraCtrl    │◄──►│ - PhaseProcessor│
│ - UI Controls   │    │ - ArduinoCtrl   │    │ - Visualizer    │
│ - Event Handler │    │ - Device Mgmt   │    │ - DPI Recorder  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │ Config Module   │
                    │                 │
                    │ - Parameters    │
                    │ - Constants     │
                    │ - Settings      │
                    └─────────────────┘
```

### 2.2 Модуль пользовательского интерфейса (GUI)

#### 2.2.1 Класс MainWindow

Главный класс приложения, наследующий от `QMainWindow`, обеспечивает:

- Инициализацию всех компонентов системы
- Управление жизненным циклом приложения
- Координацию взаимодействия между модулями
- Обработку пользовательских событий

**Основные методы:**
- `__init__()` - инициализация окна и компонентов
- `setup_ui()` - создание пользовательского интерфейса
- `setup_connections()` - настройка сигналов и слотов
- `start_measurement()` - запуск процесса измерения
- `save_image()` - сохранение результатов

#### 2.2.2 Многопоточная архитектура

Система использует многопоточность для обеспечения отзывчивости интерфейса:

**CameraStreamWorker** - поток для захвата видео:
```python
class CameraStreamWorker(QThread):
    frame_ready = Signal(np.ndarray)
    
    def run(self):
        while self.running:
            frame = self.camera_controller.get_frame()
            if frame is not None:
                self.frame_ready.emit(frame)
```

**MeasurementWorker** - поток для обработки измерений:
```python
class MeasurementWorker(QThread):
    measurement_complete = Signal(np.ndarray)
    progress_update = Signal(int)
    
    def run(self):
        # Выполнение алгоритма фазового анализа
        result = self.phase_processor.process_measurement(...)
        self.measurement_complete.emit(result)
```

### 2.3 Модуль управления оборудованием (Hardware)

#### 2.3.1 Класс CameraController

Обеспечивает управление видеокамерой через OpenCV:

**Функциональность:**
- Автоматическое обнаружение доступных камер
- Настройка разрешения и частоты кадров
- Захват кадров в реальном времени
- Управление параметрами экспозиции

**Ключевые методы:**
```python
def list_cameras(self) -> List[int]:
    """Возвращает список доступных камер"""
    
def start_capture(self, camera_index: int, 
                 resolution: Tuple[int, int] = (640, 480),
                 fps: int = 30) -> bool:
    """Запуск захвата с указанными параметрами"""
    
def get_frame(self) -> Optional[np.ndarray]:
    """Получение текущего кадра"""
```

#### 2.3.2 Класс ArduinoController

Управляет связью с Arduino-контроллером для автоматизации фазовых сдвигов:

**Протокол связи:**
- Скорость: 57600 бод
- Формат команд: ASCII строки
- Подтверждение выполнения команд

**Методы управления:**
```python
def connect(self, port: str, baudrate: int = 57600) -> bool:
    """Подключение к Arduino"""
    
def send_command(self, command: str) -> bool:
    """Отправка команды и ожидание подтверждения"""
    
def move_to_position(self, position: int) -> bool:
    """Перемещение в заданную позицию"""
```

### 2.4 Модуль обработки данных (Core)

#### 2.4.1 Класс PhaseProcessor

Центральный компонент для обработки фазовых данных:

**Алгоритмы фазового анализа:**

1. **Трехшаговый алгоритм:**
   ```python
   def compute_phase_3_step(self, images: List[np.ndarray]) -> np.ndarray:
       I0, I1, I2 = images
       numerator = np.sqrt(3) * (I2 - I1)
       denominator = 2 * I0 - I1 - I2
       return np.arctan2(numerator, denominator)
   ```

2. **Четырехшаговый алгоритм:**
   ```python
   def compute_phase_4_step(self, images: List[np.ndarray]) -> np.ndarray:
       I0, I1, I2, I3 = images
       numerator = I0 - I2
       denominator = I3 - I1
       return np.arctan2(numerator, denominator)
   ```

3. **Пятишаговый алгоритм:**
   ```python
   def compute_phase_5_step(self, images: List[np.ndarray]) -> np.ndarray:
       I0, I1, I2, I3, I4 = images
       numerator = 2 * (I1 - I3)
       denominator = 2 * I2 - I0 - I4
       return np.arctan2(numerator, denominator)
   ```

**Развертка фазы:**
Использует алгоритм Goldstein из библиотеки scikit-image для устранения 2π-разрывов:
```python
def unwrap_phase(self, wrapped_phase: np.ndarray) -> np.ndarray:
    from skimage.restoration import unwrap_phase
    return unwrap_phase(wrapped_phase)
```

**Удаление трендов:**
```python
def remove_linear_trend(self, phase: np.ndarray) -> np.ndarray:
    """Удаление линейного тренда по строкам и столбцам"""
    
def remove_polynomial_trend(self, phase: np.ndarray, 
                          degree: int = 2) -> np.ndarray:
    """Удаление полиномиального тренда заданной степени"""
```

#### 2.4.2 Класс Visualizer

Отвечает за визуализацию фазовых данных:

**Цветовое кодирование:**
- Загрузка цветовой палитры из CSV-файла (1280 цветов)
- Нормализация фазовых значений к диапазону палитры
- Создание RGB-изображений

```python
def create_color_image(self, phase_data: np.ndarray, 
                      colormap: np.ndarray,
                      invert: bool = False) -> np.ndarray:
    """Создание цветного изображения из фазовых данных"""
```

**Генерация интерферограмм:**
```python
def generate_interferogram(self, images: List[np.ndarray], 
                         method: str = 'average') -> np.ndarray:
    """Создание интерферограммы различными методами"""
```

#### 2.4.3 Класс DPIRecorder

Обеспечивает запись последовательности измерений:

**Функциональность:**
- Автоматическое создание структуры папок
- Сохранение фазовых данных в различных форматах
- Создание файлов метаданных
- Генерация сводных отчетов

```python
def start_recording(self, output_dir: str) -> bool:
    """Начало записи в указанную директорию"""
    
def record_measurement(self, phase_data: np.ndarray, 
                      metadata: dict) -> str:
    """Запись одного измерения с метаданными"""
```

## 3. Математические основы

### 3.1 Теория фазового сдвига

Интенсивность интерферограммы описывается уравнением:
```
I(x,y) = I₀(x,y) + I₁(x,y)cos[φ(x,y) + δ]
```

где:
- I₀(x,y) - фоновая интенсивность
- I₁(x,y) - амплитуда модуляции
- φ(x,y) - искомое фазовое распределение
- δ - управляемый фазовый сдвиг

### 3.2 Алгоритмы восстановления фазы

#### 3.2.1 Трехшаговый алгоритм

При фазовых сдвигах 0°, 120°, 240°:
```
I₁ = I₀ + I₁cos(φ)
I₂ = I₀ + I₁cos(φ + 2π/3)
I₃ = I₀ + I₁cos(φ + 4π/3)
```

Фаза вычисляется как:
```
φ = arctan[√3(I₃ - I₂)/(2I₁ - I₂ - I₃)]
```

#### 3.2.2 Четырехшаговый алгоритм

При фазовых сдвигах 0°, 90°, 180°, 270°:
```
φ = arctan[(I₁ - I₃)/(I₄ - I₂)]
```

#### 3.2.3 Пятишаговый алгоритм

При равномерных фазовых сдвигах π/2:
```
φ = arctan[2(I₂ - I₄)/(2I₃ - I₁ - I₅)]
```

### 3.3 Развертка фазы

Алгоритм устранения 2π-разрывов основан на минимизации функционала:
```
E = ∫∫[∇φᵤ - ∇φw]²dxdy
```

где φᵤ - развернутая фаза, φw - свернутая фаза.

### 3.4 Удаление трендов

#### 3.4.1 Линейный тренд

Удаление наклона поверхности:
```
φcorrected = φ - ax - by - c
```

#### 3.4.2 Полиномиальный тренд

Аппроксимация полиномом степени n:
```
T(x,y) = Σᵢ₌₀ⁿ Σⱼ₌₀ⁿ⁻ⁱ aᵢⱼxⁱyʲ
```

## 4. Конфигурация системы

### 4.1 Параметры алгоритмов

```python
# Алгоритмические параметры
DEFAULT_STEPS = 3                    # Количество шагов
DEFAULT_LAMBDA = 632.8               # Длина волны (нм)
DEFAULT_THRESHOLD = 0.8              # Порог качества
DEFAULT_DELAY = 300                  # Задержка между кадрами (мс)

# Параметры обработки
UNWRAP_ENABLED = True                # Развертка фазы
TREND_REMOVAL = True                 # Удаление тренда
POLYNOMIAL_DEGREE = 2                # Степень полинома
```

### 4.2 Параметры камеры

```python
# Настройки камеры
DEFAULT_CAMERA_INDEX = 0             # Индекс камеры
DEFAULT_CAMERA_RESOLUTION = (640, 480) # Разрешение
DEFAULT_CAMERA_FPS = 30              # Частота кадров
CAMERA_EXPOSURE = -6                 # Экспозиция
```

### 4.3 Параметры Arduino

```python
# Настройки Arduino
DEFAULT_ARDUINO_PORT = "COM3"        # COM-порт
DEFAULT_ARDUINO_BAUDRATE = 57600     # Скорость передачи
ARDUINO_TIMEOUT = 5.0                # Таймаут соединения
```

## 5. Форматы данных

### 5.1 Входные данные

**Изображения:**
- Формат: BGR/RGB (OpenCV)
- Разрешение: настраиваемое (по умолчанию 640×480)
- Глубина: 8 бит на канал
- Преобразование в оттенки серого для обработки

**Цветовая палитра:**
- Формат: CSV
- Структура: HEX-коды цветов
- Количество: 1280 цветов

### 5.2 Выходные данные

**Фазовые изображения:**
- Формат: PNG
- Цветовое кодирование: RGB
- Метаданные: параметры измерения

**Численные данные:**
- Формат: CSV
- Структура: матрица фазовых значений
- Заголовки: координаты и метаданные

**Интерферограммы:**
- Формат: PNG/TIFF
- Типы: усредненная, первая, последняя

## 6. Производительность и оптимизация

### 6.1 Вычислительная сложность

**Алгоритмы фазового анализа:**
- Временная сложность: O(n×m) для изображения n×m
- Пространственная сложность: O(k×n×m) для k изображений

**Развертка фазы:**
- Временная сложность: O(n×m×log(n×m))
- Использует быстрое преобразование Фурье

### 6.2 Оптимизации

**Многопоточность:**
- Захват кадров в отдельном потоке
- Обработка данных в фоновом режиме
- Неблокирующий пользовательский интерфейс

**Память:**
- Освобождение неиспользуемых массивов
- Оптимизация типов данных (float32 вместо float64)
- Переиспользование буферов

## 7. Обработка ошибок

### 7.1 Типы ошибок

**Аппаратные ошибки:**
- Отсутствие камеры
- Ошибки подключения Arduino
- Недостаточные права доступа

**Алгоритмические ошибки:**
- Недостаточное качество изображений
- Переполнение при вычислениях
- Некорректные параметры

**Системные ошибки:**
- Недостаток памяти
- Ошибки файловой системы
- Нарушение целостности данных

### 7.2 Стратегии обработки

```python
try:
    result = self.phase_processor.compute_phase(images, steps)
except InsufficientDataError as e:
    self.show_error_message("Недостаточно данных для обработки")
except ComputationError as e:
    self.show_error_message(f"Ошибка вычислений: {e}")
except Exception as e:
    self.logger.error(f"Неожиданная ошибка: {e}")
    self.show_error_message("Произошла неожиданная ошибка")
```

## 8. Тестирование и валидация

### 8.1 Модульные тесты

**Тестирование алгоритмов:**
```python
def test_phase_computation_3_step():
    # Создание синтетических данных
    phase_true = np.random.rand(100, 100) * 2 * np.pi
    images = generate_synthetic_interferograms(phase_true, 3)
    
    # Вычисление фазы
    phase_computed = processor.compute_phase_3_step(images)
    
    # Проверка точности
    assert np.allclose(phase_true, phase_computed, atol=0.1)
```

### 8.2 Интеграционные тесты

**Тестирование взаимодействия компонентов:**
- Проверка связи GUI-Hardware
- Валидация потоков данных
- Тестирование сценариев использования

### 8.3 Тесты производительности

**Бенчмарки:**
- Время обработки различных размеров изображений
- Использование памяти
- Пропускная способность системы

## 9. Развертывание и сопровождение

### 9.1 Требования к развертыванию

**Минимальные требования:**
- Python 3.8+
- 4 ГБ оперативной памяти
- 1 ГБ свободного места на диске
- USB-порт для камеры

**Рекомендуемые требования:**
- Python 3.10+
- 8 ГБ оперативной памяти
- SSD-накопитель
- Выделенная видеокарта (для ускорения вычислений)

### 9.2 Процедура установки

1. **Подготовка окружения:**
   ```bash
   python -m venv venv
   source venv/bin/activate  # Linux/macOS
   venv\Scripts\activate     # Windows
   ```

2. **Установка зависимостей:**
   ```bash
   pip install -r requirements.txt
   ```

3. **Проверка установки:**
   ```bash
   python -m pytest tests/
   python main.py --test-mode
   ```

### 9.3 Мониторинг и логирование

**Система логирования:**
```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mii4_60.log'),
        logging.StreamHandler()
    ]
)
```

**Метрики производительности:**
- Время обработки измерений
- Использование ресурсов системы
- Частота ошибок

## 10. Расширение функциональности

### 10.1 Добавление новых алгоритмов

**Интерфейс для новых алгоритмов:**
```python
class PhaseAlgorithm(ABC):
    @abstractmethod
    def compute_phase(self, images: List[np.ndarray]) -> np.ndarray:
        pass
    
    @abstractmethod
    def get_required_steps(self) -> int:
        pass
```

### 10.2 Интеграция с внешними системами

**API для внешних приложений:**
```python
class MII4_60_API:
    def __init__(self):
        self.processor = PhaseProcessor()
    
    def process_measurement(self, images: List[bytes], 
                          parameters: dict) -> dict:
        # Обработка измерения через API
        pass
```

### 10.3 Плагинная архитектура

**Система плагинов:**
- Динамическая загрузка модулей
- Регистрация новых алгоритмов
- Расширение пользовательского интерфейса

## 11. Безопасность

### 11.1 Защита данных

**Шифрование:**
- Шифрование чувствительных конфигурационных данных
- Безопасное хранение калибровочных параметров

**Контроль доступа:**
- Разграничение прав пользователей
- Аудит операций с данными

### 11.2 Валидация входных данных

```python
def validate_measurement_parameters(parameters: dict) -> bool:
    required_fields = ['steps', 'wavelength', 'delay']
    for field in required_fields:
        if field not in parameters:
            raise ValidationError(f"Отсутствует параметр: {field}")
    
    if not 3 <= parameters['steps'] <= 5:
        raise ValidationError("Количество шагов должно быть от 3 до 5")
    
    return True
```

## 12. Заключение

Система MII4_60 Python представляет собой современное решение для цифровой интерферометрии, сочетающее в себе надежные математические алгоритмы, модульную архитектуру и удобный пользовательский интерфейс. Система обеспечивает высокую точность измерений, гибкость настройки и возможности для дальнейшего развития.

Ключевые преимущества системы:
- Поддержка множественных алгоритмов фазового анализа
- Автоматизация процесса измерений
- Интуитивно понятный интерфейс
- Расширяемая архитектура
- Высокая производительность

Система может быть успешно применена в научных исследованиях, промышленном контроле качества и образовательных целях, обеспечивая надежные и воспроизводимые результаты интерферометрических измерений.

## Основные файлы

### 1. main.py
**Назначение**: Точка входа в приложение

**Функции**:
- Инициализация Qt приложения
- Создание и отображение главного окна
- Запуск основного цикла событий

**Алгоритм**:
1. Создает экземпляр QApplication
2. Инициализирует MainWindow
3. Отображает окно
4. Запускает цикл обработки событий Qt

---

### 2. config.py
**Назначение**: Централизованное хранение конфигурационных параметров

**Основные параметры**:
- `DEFAULT_STEPS = 3` - количество шагов по умолчанию
- `DEFAULT_LAMBDA = 632.8` - длина волны в нм (He-Ne лазер)
- `DEFAULT_THRESHOLD = 0.8` - пороговое значение
- `DEFAULT_DELAY = 300` - задержка между измерениями в мс
- `DEFAULT_CAMERA_RESOLUTION = (640, 480)` - разрешение камеры
- `DEFAULT_ARDUINO_BAUDRATE = 57600` - скорость Arduino
- `ARDUINO_PINS = list(range(2, 11))` - используемые пины Arduino
- `COLORMAP_SIZE = 1280` - размер цветовой палитры

---

### 3. requirements.txt
**Назначение**: Список зависимостей Python

**Основные библиотеки**:
- `PySide6` - GUI фреймворк (Qt для Python)
- `opencv-python` - компьютерное зрение и захват видео
- `numpy` - численные вычисления
- `scikit-image` - обработка изображений (развертка фазы)
- `scipy` - научные вычисления
- `pyserial` - работа с последовательным портом
- `imageio`, `pillow`, `tifffile` - работа с изображениями

---

## Модуль core/

### 1. dpi_recorder.py

**Класс**: `DPIRecorder(QObject)`

**Назначение**: Запись последовательности фазовых измерений в файлы

**Основные методы**:

#### `start_recording(output_directory)`
- **Параметры**: `output_directory` (str) - путь к папке для сохранения
- **Возвращает**: bool - успешность операции
- **Алгоритм**:
  1. Проверяет, не идет ли уже запись
  2. Создает выходную папку
  3. Инициализирует счетчики и время начала
  4. Испускает сигнал `recording_started`

#### `stop_recording()`
- **Алгоритм**: Останавливает запись и испускает сигнал `recording_stopped`

#### `save_phase_data(phase_data, phase_image)`
- **Параметры**: 
  - `phase_data` (numpy.ndarray) - 2D массив фазовых данных
  - `phase_image` (QImage/numpy.ndarray) - изображение фазы
- **Алгоритм**:
  1. Генерирует уникальное имя файла с временной меткой
  2. Сохраняет изображение в PNG формате
  3. Сохраняет данные в CSV формат через `_save_phase_to_csv()`
  4. Увеличивает счетчик изображений
  5. Испускает сигнал `image_saved`

#### `_save_phase_to_csv(phase_data, csv_path)`
- **Алгоритм**:
  1. Записывает заголовок с метаданными
  2. Построчно записывает фазовые данные в CSV

#### `create_summary_file()`
- **Алгоритм**: Создает текстовый файл с сводкой записи (количество файлов, время записи)

**Сигналы Qt**:
- `recording_started` - начало записи
- `recording_stopped` - окончание записи
- `image_saved(int, str)` - сохранение изображения
- `error_occurred(str)` - ошибка

---

### 2. phase_processor.py

**Класс**: `PhaseProcessor`

**Назначение**: Выполнение всех вычислений, связанных с обработкой фазы

#### `__init__(lambda_nm=632.8)`
- **Параметры**: `lambda_nm` (float) - длина волны в нанометрах

#### `compute_phase(images, steps)`
- **Параметры**: 
  - `images` (list) - список изображений интерферограмм
  - `steps` (int) - количество фазовых шагов (3, 4 или 5)
- **Возвращает**: numpy.ndarray - "свернутая" фаза
- **Алгоритм**:
  
  **Для 3 шагов**:
  ```
  numerator = √3 * (I₂ - I₁)
  denominator = 2*I₀ - I₁ - I₂
  phase = arctan2(numerator, denominator)
  ```
  
  **Для 4 шагов**:
  ```
  numerator = I₀ - I₂
  denominator = I₃ - I₁
  phase = arctan2(numerator, denominator)
  ```
  
  **Для 5 шагов**:
  ```
  numerator = 2 * (I₁ - I₃)
  denominator = 2*I₂ - I₀ - I₄
  phase = arctan2(numerator, denominator)
  ```

#### `unwrap_phase(wrapped_phase)`
- **Параметры**: `wrapped_phase` (numpy.ndarray) - свернутая фаза
- **Возвращает**: numpy.ndarray - развернутая фаза
- **Алгоритм**: Использует функцию `unwrap_phase` из scikit-image для устранения разрывов фазы

#### `remove_linear_trend(phase_data)`
- **Параметры**: `phase_data` (numpy.ndarray) - фазовые данные
- **Возвращает**: numpy.ndarray - данные без линейного тренда
- **Алгоритм**:
  1. Удаляет линейный тренд по строкам (полином 1-й степени)
  2. Удаляет линейный тренд по столбцам
  3. Использует метод наименьших квадратов для подгонки

#### `remove_polynomial_trend(phase_data)`
- **Параметры**: `phase_data` (numpy.ndarray) - фазовые данные
- **Возвращает**: numpy.ndarray - данные без полиномиального тренда
- **Алгоритм** (аналог sphereTrend из Java):
  1. Извлекает горизонтальный профиль (первая строка)
  2. Извлекает вертикальный профиль (первый столбец)
  3. Вычисляет полиномиальные тренды 2-го порядка
  4. Удаляет тренды из всех строк и столбцов

#### `_fit_polynomial_trend(profile, size)`
- **Параметры**: 
  - `profile` (numpy.ndarray) - одномерный профиль
  - `size` (int) - размер профиля
- **Возвращает**: numpy.ndarray - полиномиальный тренд
- **Алгоритм**:
  1. Создает матрицу A для полинома: y = w₁ + w₂*x + w₃*x²
  2. Решает систему A^T * A * w = A^T * y методом наименьших квадратов
  3. Вычисляет полиномиальный тренд по найденным коэффициентам

---

### 3. visualizer.py

**Функции модуля**:

#### `load_colormap(filepath)`
- **Параметры**: `filepath` (str) - путь к CSV файлу с цветами
- **Возвращает**: numpy.ndarray - массив цветов в формате BGR
- **Алгоритм**:
  1. Загружает HEX цвета из CSV
  2. Конвертирует HEX в BGR формат (для OpenCV)
  3. Возвращает массив цветов как lookup table

#### `create_phase_image(phase_data, colormap, inverse=False)`
- **Параметры**:
  - `phase_data` (numpy.ndarray) - 2D массив фазовых данных
  - `colormap` (numpy.ndarray) - цветовая палитра
  - `inverse` (bool) - инверсия цветов
- **Возвращает**: numpy.ndarray - цветное изображение
- **Алгоритм**:
  1. Находит минимальное и максимальное значения фазы
  2. Нормализует данные в диапазон индексов палитры [0, len(colormap)-1]
  3. Использует палитру как lookup table для создания цветного изображения

#### `create_interferogram(images, method='average')`
- **Параметры**:
  - `images` (list) - список изображений
  - `method` (str) - метод создания ('average', 'first', 'last')
- **Возвращает**: numpy.ndarray - интерферограмма
- **Алгоритм**:
  - `'average'`: усредняет все изображения
  - `'first'`: использует первое изображение
  - `'last'`: использует последнее изображение

#### `save_data_to_csv(data, filepath)`
- **Параметры**:
  - `data` (numpy.ndarray) - 2D массив данных
  - `filepath` (str) - путь к файлу
- **Алгоритм**:
  1. Записывает заголовок с метаданными
  2. Построчно сохраняет данные в CSV формате

---

## Модуль gui/

### main_window.py

**Классы**:

#### `MeasurementWorker(QThread)`
**Назначение**: Выполнение измерений в отдельном потоке

**Методы**:

##### `__init__(camera, arduino, params)`
- **Параметры**: контроллеры оборудования и параметры измерения

##### `run()`
- **Алгоритм**:
  1. Цикл по количеству шагов
  2. Отправка команды Arduino для сдвига фазы
  3. Задержка согласно параметрам
  4. Захват кадра с камеры
  5. Вычисление фазы через PhaseProcessor
  6. Применение развертки фазы (опционально)
  7. Удаление тренда (опционально)
  8. Создание цветного изображения
  9. Испускание сигнала с результатом

##### `stop()`
- **Алгоритм**: Устанавливает флаг остановки потока

**Сигналы**:
- `new_image(np.ndarray)` - новое изображение
- `finished()` - завершение измерения
- `error(str)` - ошибка

#### `MainWindow(QMainWindow)`
**Назначение**: Главное окно приложения

**Основные методы**:

##### `__init__()`
- **Алгоритм**:
  1. Инициализация контроллеров оборудования
  2. Создание DPI recorder
  3. Подключение сигналов
  4. Инициализация UI
  5. Заполнение списков устройств

##### `_init_ui()`
- **Алгоритм**: Создает пользовательский интерфейс с элементами управления и областью отображения

##### `setup_advanced_controls()`
- **Алгоритм**: Добавляет расширенные элементы управления (DPI запись, экспорт, тренды)

##### `_populate_devices()`
- **Алгоритм**: Заполняет выпадающие списки доступными камерами и портами Arduino

##### `start_measurement()`
- **Алгоритм**:
  1. Проверяет подключение камеры
  2. Собирает параметры измерения из UI
  3. Создает и запускает MeasurementWorker
  4. Подключает сигналы worker'а

##### `update_image(cv_img)`
- **Параметры**: `cv_img` (numpy.ndarray) - изображение для отображения
- **Алгоритм**:
  1. Применяет полиномиальное удаление тренда (если включено)
  2. Сохраняет данные в DPI recorder (если запись активна)
  3. Конвертирует numpy array в QImage
  4. Масштабирует и отображает изображение

##### `toggle_dpi_recording()`
- **Алгоритм**: Переключает состояние DPI записи, запрашивает папку для сохранения

##### `export_phase_data_csv()`
- **Алгоритм**: Экспортирует текущие фазовые данные в CSV файл

---

## Модуль hardware/

### controller.py

**Классы**:

#### `CameraController`
**Назначение**: Управление захватом видео с камеры

**Методы**:

##### `list_cameras()` (статический)
- **Возвращает**: list - список доступных камер
- **Алгоритм**:
  1. Перебирает индексы камер от 0
  2. Пытается открыть каждую камеру через OpenCV
  3. Проверяет возможность чтения кадра
  4. Возвращает список найденных камер

##### `start(index, resolution=None, fps=None)`
- **Параметры**: индекс камеры, разрешение, FPS
- **Алгоритм**:
  1. Останавливает предыдущий захват
  2. Открывает камеру с DirectShow backend
  3. Устанавливает разрешение и FPS
  4. Устанавливает флаг активности

##### `get_frame()`
- **Возвращает**: numpy.ndarray - кадр в оттенках серого
- **Алгоритм**:
  1. Читает кадр с камеры
  2. Конвертирует из BGR в оттенки серого
  3. Возвращает результат

##### `stop()`
- **Алгоритм**: Освобождает ресурсы камеры

#### `ArduinoController`
**Назначение**: Управление Arduino для сдвига фазы

**Методы**:

##### `list_ports()` (статический)
- **Возвращает**: list - список доступных COM-портов
- **Алгоритм**: Использует pyserial для сканирования портов

##### `connect(port, baudrate=None)`
- **Параметры**: порт, скорость передачи
- **Алгоритм**:
  1. Отключается от предыдущего соединения
  2. Открывает последовательный порт
  3. Ждет 2 секунды для инициализации
  4. Вызывает `_initialize_pins()`

##### `_initialize_pins()`
- **Алгоритм**:
  1. Устанавливает все пины 2-10 как OUTPUT
  2. Устанавливает все пины в LOW состояние
  3. Устанавливает пин 8 в HIGH (как в оригинале)

##### `send_step_command(step_index)`
- **Параметры**: `step_index` (int) - индекс шага (0-4)
- **Алгоритм** (реализация функции step() из Java):
  1. Устанавливает все пины 2-10 в LOW
  2. Устанавливает целевой пин (step_index + 2) в HIGH
  3. Отправляет команды через последовательный порт
  4. Обновляет текущий шаг

##### `reset_all_pins()`
- **Алгоритм**: Сбрасывает все пины Arduino в LOW состояние

---

## Модуль data/

### colorArray.csv
**Назначение**: Цветовая палитра для визуализации фазы

**Структура**: 1280 строк с HEX цветами в формате AARRGGBB
- Первые цвета: красно-желтая гамма (FFFF0000 → FFFF3100)
- Полный спектр от красного через желтый, зеленый, голубой до фиолетового
- Используется как lookup table для преобразования фазовых значений в цвета

---

## Алгоритмы и принципы работы

### 1. Цифровая интерферометрия (DPI)
**Принцип**: Измерение фазы световой волны через анализ интерференционных картин

**Этапы**:
1. **Захват серии интерферограмм** с известными фазовыми сдвигами
2. **Вычисление свернутой фазы** по алгоритмам 3, 4 или 5 шагов
3. **Развертка фазы** для устранения 2π разрывов
4. **Удаление трендов** для компенсации систематических ошибок
5. **Визуализация** через цветовое кодирование

### 2. Алгоритм фазовых шагов
**3 шага** (сдвиг 120°):
- Требует минимум измерений
- Менее устойчив к шумам
- Формула: φ = arctan2(√3(I₂-I₁), 2I₀-I₁-I₂)

**4 шага** (сдвиг 90°):
- Оптимальный баланс точности и скорости
- Формула: φ = arctan2(I₀-I₂, I₃-I₁)

**5 шагов** (сдвиг 72°):
- Максимальная точность
- Лучшее подавление гармоник
- Формула: φ = arctan2(2(I₁-I₃), 2I₂-I₀-I₄)

### 3. Развертка фазы
**Проблема**: Функция arctan2 возвращает значения в диапазоне [-π, π]
**Решение**: Алгоритм развертки устраняет скачки ±2π между соседними пикселями
**Реализация**: Использует scikit-image.restoration.unwrap_phase

### 4. Удаление трендов
**Линейный тренд**: Удаляет наклон по строкам и столбцам
**Полиномиальный тренд**: Удаляет искривления 2-го порядка (сферические аберрации)

### 5. Управление Arduino
**Протокол команд**:
- `PINMODE:pin:OUTPUT` - настройка пина как выход
- `DIGITAL:pin:HIGH/LOW` - установка состояния пина
- Пины 2-6 используются для фазовых шагов
- Пин 8 всегда в HIGH состоянии